\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pgfplots}
\usepackage{circuitikz}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
	decorations.pathreplacing,decorations.pathmorphing,shapes,%
	matrix,shapes.symbols}

\tikzset{
	>=stealth',
	punktchain/.style={
		rectangle, 
		rounded corners, 
		draw=black, very thick,
		text width=10em, 
		minimum height=3em, 
		text centered, 
		on chain},
	line/.style={draw, thick, <-},
	element/.style={
		tape,
		top color=white,
		bottom color=blue!50!black!60!,
		minimum width=8em,
		draw=blue!40!black!90, very thick,
		text width=10em, 
		minimum height=3.5em, 
		text centered, 
		on chain},
	every join/.style={->, thick,shorten >=1pt},
	decoration={brace},
	tuborg/.style={decorate},
	tubnode/.style={midway, right=2pt},
}

\pgfmathdeclarefunction{gauss}{2}{%
	\pgfmathparse{1/(#2*sqrt(2*pi))*exp(-((x-#1)^2)/(2*#2^2))}%
}

\title{Relatório 1  \\
	Projeto em Eletrônica I - EEL7801 \\ \vfill
	\normalsize{Universidade Federal de Santa Catarina - UFSC \\
		Professora: Daniela Ota Hisayasu Suzuki}
	\author{
		{Luiz Augusto Frazatto Fernandes: \it{17202752}} \\
		{Leonardo José Held: \it{17203984}}
	}
}
\date{02 de Maio de 2019}
\begin{document}
	

	\maketitle
	%todo: atualizar pro link do github do Robota quando empurrarmos o projeto pra lá
		\newpage Nota: O projeto todo, incluindo este documento e os demais códigos de simulação e de projeto podem ser encontrados em \url{https://github.com/leonheld/EEL7801}
	\\
	
	\setcounter{chapter}{0}
	\chapter{Metodologia}
	\section{Modulação e demodulação de sinais}
	\subsection{Motivação da escolha do algoritmo}
	
	Escolheu-se o processo de modulação por Chaveamento de Deslocamento de Frequência (FSK, em inglês). São usadas duas frequências ótimas para se representar 0 e 1, e ambas são obtidas experimentalmente: a partir de testes realizados com o transdutor (microfone), é gerada uma curva normal, em que a resposta desse ao sinal recebido é ótima para uma frequência específica (frequência da onda portadora). São, então, obtidas duas outras frequências equidistantes do centro da curva gaussiana, e a cada uma é associado um valor binário.
	
	
	O processo de modulação, em si, consiste na transformação de um sinal PWM em um analógico (que é controlado por um STM32) que, por sua vez, é emitido por um tweeter. O sinal (sonoro) é recebido por um microfone controlado por outro STM32, que realizará o processo de demodulação do sinal.
	\subsection{Algoritmo da modulação (FSK)}	

	Empiricamente são testadas (com o microfone) diferentes frequências emitidas pelo tweeter e recebidas pelo microfone. A de melhor resposta (dada, no gráfico abaixo, por $f$) é associada à onda portadora (carrier). É, então, estabelecido um desvio $\Delta{f}$, e, a partir desse, são determinadas:
	\begin{center}
		\begin{align*}
		f_L = f - \Delta{f}\\
		f_H = f + \Delta{f}
		\end{align*}
	\end{center}
	de tal forma que à $f_H$ se associa o bit $1$, e à $f_L$, $0$.
	

	
	\begin{center}
		\begin{tikzpicture}
		\begin{axis}[every axis plot 
		post/.append style={
		mark=none,domain=0:50, samples=50,smooth},
		axis x line*=bottom,
		axis y line*=left,
		xlabel = {Frequência},
		ylabel = {Resposta (queda de tensão/potência)},
		xtick=\empty,
		ytick=\empty,	
		enlargelimits=upper]
		\addplot[mark=*] coordinates {(25,10^-1)} node[pin=270:{$f$}]{} ;
		\addplot[mark=*] coordinates {(23,8*10^-2)} node[pin=150:{$f_L$}]{} ;
		\addplot[mark=*] coordinates {(27,8*10^-2)} node[pin=30:{$f_H$}]{} ;
		\addplot{gauss(25,4)};
		\end{axis}
		\end{tikzpicture}
	\end{center}


Há, também, uma segunda possibilidade: de o microfone não reagir significativamente a diferentes frequências, mas de ainda assim conseguir diferenciá-las. Isto é: o microfone identifica quando duas frequências recebidas são diferentes, mas sua curva de queda de tensão se aproxima de uma constante, como no exemplo a seguir:


\begin{center}
	\begin{tikzpicture}
	\begin{axis}[every axis plot 
	post/.append style={
	mark=none,domain=6:50, samples=50,smooth},
	axis x line*=bottom,
	axis y line*=left,
	xlabel = {Frequência},
	ylabel = {Resposta (queda de tensão/potência)},
	xtick=\empty,
	ytick=\empty,	
	enlargelimits=upper]
	\addplot {2}; 
	\end{axis}
	\end{tikzpicture}
\end{center}


	Caso esse comportamento seja verificado, o que há de se fazer é, simplesmente, escolher duas frequências quaisquer para se trabalhar no algoritmo.

\subsection{Obtenção das frequências ótimas}
\paragraph{}
Por meio do circuito da (inserir número da imagem aqui) é medida a tensão/potência dissipada nos terminais do microfone. A curva (próxima à normal descrita acima) é gerada a partir da potência consumida/queda de tensão que é medida entre os terminais do microfone.


\begin{center}
	\begin{circuitikz} \draw
		(0,0) to (6,0) 
		to [vR, l=$Microfone$] (6,3)
		to [resistor, l=$R$] (0,3)
		to [vsourcesin, l= $Gerador$] (0,0)
		(2,0) to (2,-1) node[ground] {}
		(6,0) -- (9,0)
		(6,3) to (9,3)
		(9,0) to [voltmeter, l=$Voltimetro$] (9,3)
		;
	\end{circuitikz}
\end{center}


Quanto maior a queda de tensão no microfone, maior a energia por ele consumida em relação ao resto do circuito (divisor de tensão), logo, melhor será sua resposta aos estí­mulos sonoros testados.

	\subsection{Tratamento do sinal analógico}

Será utilizado, a priori, um filtro passa-baixa a fim de reduzir o ruído de alta frequência, além de um amplificador não inversor (que garantirá uma clara análise do sinal).

\begin{center}
	\begin{circuitikz} \draw
		(0, 0) node[op amp] (opamp) {}
		(opamp.-) -- (-3, 0.5)
		to[C, l=$C$] (-3, -4)
		(-3, 0.5) to[R, *-, l=$R_1$] (-6, 0.5) node[label={$V_{in}$}] {}
		(opamp.+) to[short,*-] ++(0,-1.5) coordinate (leftR)
		to[R, l=$R_3$] (leftR -| opamp.out)
		to[short,-*] (opamp.out)
		to ++(1,0) node[label={$V_{out}$}] {}
		(-1, -2) to[R, *-, l=$R_2$] (-1,-4)
		(-3, -4) -- (-1, -4)
		(-2,-4) to (-2,-5) node[ground] {}
		;
	\end{circuitikz}
\end{center}


	A frequência de corte do circuito acima é dada por \newline
	\begin{equation}
	f_c = \frac{1}{2\cdot\pi\cdot{R_1}\cdot{C}}
	\end{equation}
	
	
	E o ganho por \newline
	\begin{equation}
	\frac{V_{out}}{V_{in}} = G = 1 + \frac{R_3}{R_2}
	\end{equation}
	
	
	Espera-se trabalhar com frequências na faixa audível ($20 Hz$ a $20 kHz$). Portanto, pode-se colocar uma frequência de corte razoável de 22 kHz a priori, já que, dessa forma, o ruído de alta frequência filtrado não interferirá nos sinais desejados.
	
	
	Para tal, usamos um capacitor com capacitância $C = 0.1\mu{F}$, o que nos resulta:
	
	\begin{equation}
	R_1 = \frac{1}{2\cdot{\pi}\cdot{0.1}\cdot{10^{-6}}\cdot{22}\cdot{10^3}} \approx 72\Omega 
	\end{equation}
	
	Para avaliarmos o ganho, deixamos em $R_3$ um potenciômetro e, assim, avaliamos, a posteriori, qual o melhor ganho para se projetar (aquele cuja análise posterior for facilitada).


\section{Escolha de Microcontrolador ($\mu$C)}
	\subsection{STM32}
	O microcontrolador foi escolhido na base da seguinte {\it criteria}:
	
	\begin{itemize}
		\item[{\bf 1)}]Baixo Custo: O controlador deve ter um custo mínimo, com alta flexibilidade de prototipação. Deve incluir um programador integrado, ou possuir algum de baixo custo e facilmente acessível.
		
		\item[{\bf 2)}] Alto suporte: O controlador deve ter suporte de compiladores, ambientes de programação, comunidade de software aberto e pela própria empresa que o fabrica.
		
		\item[{\bf 3)}] Performance: A unidade deve ter uma performance que faz processamento de dados e sinais com relativa rapidez, de forma que a sua capacidade de processamento não dite o algoritmo e execução do programa.
	
	\end{itemize}

	Em consideração aos items {\bf 1} e {\bf 2}, se optou por utilizar algum controlador da família ARM™, indubtavelmente a família mais utilizada de processadores no mundo, e desta forma, acessível e de bom suporte. \\
	
	O quesito performance nos faz olhar para as famílias de processadores que a ARM™ atualmente oferece, dentre as quais, os processadores Cortex-M3™ \footnote{https://developer.arm.com/ip-products/processors/cortex-m/cortex-m3} parecem entrar nos quesitos. \\
	
	De acordo com o página da empresa sobre o processador:\\
	
	``The Arm Cortex-M3 processor is the industry-leading 32-bit processor for highly deterministic real-time applications."\\
	
	Depois de uma curta pesquisa de mercado, a placa STM32F103C8 da ST™ parece preencher bem os quesitos supraescritos, com um processador Cortex-M3™ de 72MHz de clock interno, é um dos microcontroladores mais potentes da categoria fabricados pela ST™, o que preenche bem o requisito {\bf 3}.\\
	
	Qualquer processador dessa linha da ST™ pode ser programado e debuggado via uma interface chamada ST-Link™, que também foi de fácil obtenção e baixo custo, e basicamente inclui um outro processador que conversa em tempo real com a placa alvo.

	
	\subsection{Suporte}
	O suporte oferecido tanto pela ARM™ quanto pela ST™ é extenso. A ST™ produz seu próprio software de pré-configuração e geração de código chamado STM32CubeMX™, que é uma {\it Graphical User Interface} usada para gerar o código inicial, como configuração de clock interno e dos pinos do processador, por exemplo.\\
	
	A ARM™ também mantém um compilador, um debugger e utilidades de programação para sua linha de processadores, todas as ferramentas baseadas no GCC, GDB e Gnu Binutils.\footnote{https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain}\\
	
	Como software de upload de código e debugging, podemos usar o programa {\it openocd} \footnote{http://openocd.org/}, também de código aberto que acessa a interface SWD ({\it Serial Wire Debug}) do ST-Link™ via terminal, com possibilidade de abrir uma janela de sessão de debugging via GDB.
	
	\subsection{Processo de Desenvolvimento}
	Desde a última versão, o STM32CubeMX™ consegue produzir um Makefile que pode ser compilado pelo programa {\it make} chamando o compilador de C cedido pela ARM.\\
	
	A partir disso, o compilador gera arquivos .hex, .elf e .bin, quaisquer podendo ser inseridos na memoria interna do microcontrolador pelo openocd.\\
	
	Para a programação, existe uma HAL - {\it Hardware Abstration Layer} -, também fornecida pela ST™, que é incluída nos sources do projeto no momento da inicialização do código pelo STM32CubeMX™ e possuí funções específicas de baixo nível, mas tem as mesmas chamadas em quaisquer processador alvo que queira executar o código, aumentando a portabilidade. Também, a HAL é construída de forma a aumentar o nível de abstração, diminuindo significativamente a complexidade do código, permitindo desenvolvimento rápido e colaborativo, sem necessariamente conhecer todos os artifícios de baixo nível de cada processador.
	\begin{center}
		\begin{tikzpicture}
	[node distance=.8cm,
	start chain=going below,]
	
	\node[punktchain, join, ] (STM) {STM32CubeMX};
	\node (gcc) [punktchain ] {GCC};
	\begin{scope}[start branch=top,
	every join/.style={->, thick, shorten <=1pt}, ]
	\node[punktchain, on chain=going left, join=by {<-}](HAL) {HAL};
	\end{scope}
	\begin{scope}[start branch=bottom,]
	\node (makefile) [punktchain, on chain=going right] {Makefile};
	\end{scope}
	\node[punktchain, join,] {$.elf\ .bin\ .hex$};
	\node[punktchain, join,] {OpenOCD};
	\node[punktchain, join]  {ST-Link};
	
	\draw[<-] (gcc.east) -- (makefile.west);
	\draw[<-] (makefile.north) -- (STM.east);
	\draw[<-] (HAL.north) -- (STM.west);
	\end{tikzpicture}
	\end{center}
\chapter{Title}
	\section{Title}
	\subsection{title}
	
	
\end{document}